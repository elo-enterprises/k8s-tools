## compose.mk

*`compose.mk`* includes macros which can **[build a bridge between docker-compose services and make-targets](#makecompose-bridge)** at the same time as it provides a [**minimum viable pattern for container-dispatch.**](#container-dispatch)

The main macro is called *`compose.import`*, which can be used/included from any Makefile, used with any compose file, and [used with *multiple* compose files](#multiple-compose-files).  

If you prefer to learn from examples, you might want to just [get started](#makecompose-bridge) or skip to the main [cluster automation demo](#demo-cluster-automation).  If you're the type that needs to hear the motivation first, read on in the next section.

----------------------------------------------------

### But Why?

There's many reasons why you might want these capabilities if you're working with tool-containers, builds, deploys, and complex task orchestration.  People tend to have strong opions about this topic, and it's kind of a long story.  

The short version is this: Makefiles run practically everywhere and most people can read/write them.  They're also really good at describing DAGs, and lots of automation, but *especially life-cycle automation*, is a natural fit for this paradigm.  The only trouble is that a) *make has nothing like native support for tasks in containers*, and b) *describing the containers themselves is even further outside of it's domain*.  Meanwhile, docker-compose is exactly the opposite.Make/Compose are already a strong combination for this reason, and by adding some syntactic sugar using compose.mk, you can orchestrate make-targets across several containers without cluttering your host.  More than that, you can also bootstrap surprisingly sophisticated automation-APIs with surprisingly little effort.

If you're interested in the gory details of the longer-format answer, there's more detailed discussion in the [Design Philosophy section](#why-composemk).

----------------------------------------------------

{% include "bridge.md" %}

----------------------------------------------------

{% include "container-dispatch.md" %}

----------------------------------------------------

{% include "macro-arguments.md" %}

----------------------------------------------------

{% include "dispatch-syntax.md" %}

----------------------------------------------------

{% include "multiple-compose-files.md" %}

---------------------------------------------------------------

{% include "platform-example.md" %}

---------------------------------------------------------------

### API: compose.mk

#### API: compose.mk: (Autogenerated Targets)

The autogenerated section of the API (i.e. what's created by `compose.import`) is documented as part of the [Make/Compose Bridge](#makecompose-bridge).

#### API: (Static Targets)

This is the complete list of namespaces & targets available from compose.mk, along with their documentation.  Most documentation is pulled automatically from [the latest source](compose.mk).

Some important notes about how these targets work:

**No requirements for `k8s-tools.yml` or `k8s.mk`.**

**Most targets are pure shell, and have no exotic dependencies.** That means that they generally run fine on host or as dispatched targets inside containers.  Be mindful of these exceptions though:  targets in `stream.json.*` require `jq` and targets in `docker.*` require docker.
    
**Targets are usable interactively from your shell** as `make <target>` or `./compse.mk <target>`

**Targets are usable as an API,** either as prereq-targets or as part of the body in your targets.

Target names are reserved names after declaration, but collisions aren't likely because things are organized into a few namespaces:

* [*`io.*`*](#api-composemk-docker) targets: Misc text-formatters, timers, and other utilities
* [*`docker.*`]*(#api-composemk-docker) targets: Simple helpers for working with docker.
* [*`flux.*`]*(#api-composemk-docker) targets: Miniature workflow library / pipe wizard.
* [*`stream.*`]*(#api-composemk-stream) targets: Support for IO streams, including basic stuff with JSON, newline-delimited, and space-delimited formats.

#### API: io

The *`io.*`* targets cover various I/O helpers, text-formatters, and other utilities.

*This documentation is pulled automatically from [source](compose.mk)*

{% set targets=bash('pynchon makefile parse compose.mk| jq \'with_entries(select(.key | startswith("io")))\'', load_json=True) %}
{% for tname in targets %}
#### **`{{tname.replace('%','<arg>')}}`**

```bash 
{{ "\n".join(targets[tname].docs).strip()}}
```
{% endfor %}

#### API: docker

The *`docker.*`* targets cover a few helpers for working with docker.

*This documentation is pulled automatically from [source](compose.mk)*

{% set targets=bash('pynchon makefile parse compose.mk| jq \'with_entries(select(.key | startswith("docker")))\'', load_json=True) %}
{% for tname in targets %}
#### **`{{tname.replace('%','<arg>')}}`**

```bash 
{{ "\n".join(targets[tname].docs).strip()}}
```
{% endfor %}

#### API: flux

The *`flux.*`* targets describe a miniature workflow library.  

Combining `flux` with [container dispatch](#container-dispatch) is similar in spirit to things like [declarative pipelines in Jenkins](https://www.jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline), but simpler, more portable, and significantly easier to use.  

Most of these targets perform split/join/loop/map operations *over other make targets*.  For stuff specific to shell code, see`flux.sh.*`, and for scripts see `flux.scripts.*`.

See the [Platform Setup](#example-platform-setup) example for a more complete walk-through of motivation/use-case.

{#:

We've [seen previously](##target-svc_nameshellpipe) that `compose.mk` already makes piping data between tool containers really simple.  

```bash 
$ echo echo echo hello-world | make alpine/pipe | make debian/pipe
▰ // docker-compose // alpine container
▰ [default entrypoint] ⋘⋘⋘  echo echo hello-world
▰ // docker-compose // debian container
▰ [default entrypoint] ⋘⋘⋘  echo hello-world
hello-world
```

#}
*This documentation is pulled automatically from [source](compose.mk)*

{% set targets=bash('pynchon makefile parse compose.mk| jq \'with_entries(select(.key | startswith("flux")))\'', load_json=True) %}
{% for tname in targets %}
#### **`{{tname.replace('%','<arg>')}}`**

```bash 
{{ "\n".join(targets[tname].docs).strip()}}
```
{% endfor %}


#### API: compose.mk: stream

The `stream.*` targets support IO streams, including basic stuff with JSON, newline-delimited, and space-delimited formats.

*This documentation is pulled automatically from [source](compose.mk)*

{% set targets=bash('pynchon makefile parse compose.mk| jq \'with_entries(select(.key | startswith("stream")))\'', load_json=True) %}
{% for tname in targets %}
#### **`{{tname.replace('%','<arg>')}}`**

```bash 
{{ "\n".join(targets[tname].docs).strip()}}
```
{% endfor %}
