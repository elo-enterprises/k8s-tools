


<table style="width:100%">
  <tr>
    <td colspan=2><strong>
    k8s-tools
      </strong>&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td width=10%>
      <center>
        <img src=../img//docker.png style="width:75px"><br/>
        <img src=../img//kubernetes.png style="width:75px"><br/>
        <img src=../img//make.png style="width:75px"><br/>
      </center>
    </td>
    <td>
      Completely dockerized version of a kubernetes toolchain, plus a zero-dependency automation framework for extending and interacting it.
      <br/>
      <p align="center">
        <table width="100%" border=1><tr>
          <td><a href=/README.md#overview>Overview</a></td>
          <td><a href=/README.md#features>Features</a></td>
          <td><a href=/README.md#integration>Integration</a></td>
          <td><a href=/README.md#composemk>compose.mk</a></td>
          <td><a href=/README.md#k8smk>k8s.mk</a></td>
          <td><a href=/docs/api.md>API</a></td>
          <td><a href=/docs/demos.md>Demos</a></td>
        </tr>
        <tr><td colspan="100%">
          <a href="https://github.com/elo-enterprises/k8s-tools/actions/workflows/docker-test.yml"><img src="https://github.com/elo-enterprises/k8s-tools/actions/workflows/docker-test.yml/badge.svg"></a>
        </td></tr></table>
      </p><br/>
    </td>
  </tr>
</table>


----------------------------------------------------

## API: compose.mk

### compose.mk: (Dynamic Targets)

The autogenerated section of the API (i.e. what's created by `compose.import`) is documented as part of the [Make/Compose Bridge](#makecompose-bridge).

### compose.mk: (Static Targets)

This is the complete list of namespaces & targets available from compose.mk, along with their documentation.  Most documentation is pulled automatically from [the latest source](compose.mk).  Some important notes about how these targets work:

* **No requirements for `k8s-tools.yml` or `k8s.mk`.**
* **Most targets are pure shell, and have no exotic dependencies.** That means that they generally run fine on host or as dispatched targets inside containers.  Be mindful of these exceptions though:  targets in `stream.json.*` require `jq` and targets in `docker.*` require docker.
* **Targets are usable interactively from your shell** as `make <target>` or `./compse.mk <target>`
* **Targets are usable as an API,** either as prereq-targets or as part of the body in your targets.
* **Target names are reserved names after declaration.**

Things are organized into a few namespaces, which hopefully avoids collisions with your project targets.

* [*`io.*`* targets:](/docs/api#api-io)  Misc text-formatters, timers, and other utilities
* [*`docker.*`* targets:](/docs/api#api-docker) targets: Simple helpers for working with docker.
* [*`flux.*`*](/docs/api#api-flux) targets: Miniature workflow library / pipe wizard.
* [*`tux.*`*  targets:](/docs/api#api-tux) targets: Embedded TUI support.
* [*`stream.*`* targets:](/docs/api#api-stream) targets: Support for IO streams, including basic stuff with JSON, newline-delimited, and space-delimited formats.



#### API: tux

The *`tux.*`* targets allow for creation, configuration and automation of an embedded TUI interface.  See the [TUI documentation](#embedded-tui) for a high-level overview of what this is and how it works.  For more details, [see the main TUI docs](/#embedded-tui), read on into the API, or see the [tux container spec in compose.mk](
https://github.com/search?q=repo%3Aelo-enterprises%2Fk8s-tools+path%3Acompose.mk+content%3Atux&type=code)




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`tux.bootstrap`**


```bash 
Internal usage only
```

 
#### **`tux.commander`**


```bash 
A tmux layout defaulting to 4 panes, using the "commander" layout callback.
 See .tux.commander.layout for more details.

 USAGE:
  ./compose.mk tux.commander
```

 
#### **`tux.commander/<arg>`**


```bash 
A 4-pane session using the commander layout, and proxying the given targets into the main pane.
 See .tux.commander.layout for more details.
 
 USAGE: (Runs 'io.env' target in the primary pane)
   ./compose.mk tux.commander/io.env
```

 
#### **`tux.dispatch.sh`**


```bash 
Runs the given <cmd> into the embedded TUI container.

 USAGE:
   cmd=... ./compose.mk tux.dispatch.sh
```

 
#### **`tux.dispatch/<arg>`**


```bash 
Runs the given target inside the embedded TUI container.

 USAGE:
```

 
#### **`tux.help`**


```bash 
Lists only the targets available under the 'tux' namespace.
```

 
#### **`tux.mux.count/<arg>`**

 
* *Alias for [`tux.mux.svc/<arg>`](#tuxmuxsvcarg)*

 
#### **`tux.mux.detach/<arg>`**


```bash 
Like 'tux.mux' except without default attachment.  

 This is mostly for internal use.  Detached sessions are used mainly 
 to allow for callbacks that need to alter the session-configuration,
 prior to the session itself being entered and becoming blocking.
```

 
#### **`tux.mux.svc/<arg>`**


```bash 
Starts a split-screen display of N panes inside a tmux (actually 'tmuxp') session.

 If argument is an integer, opens the given number of shells in tmux.
 Otherwise, executes one shell per pane for each of the comma-delimited container-names.
 
 USAGE:
   ./compose.mk tux.mux.svc/<svc1>,<svc2>

 USAGE:
   ./compose.mk tux.mux.count/<int>

 This works without a tmux requirement on the host, by default using the embedded 
 container spec @ 'compose.mk:tux'.  The TUI backend can also be overridden by using
 the variables for TUI_COMPOSE_FILE & TUI_SVC_NAME.  See also k8s.mk, which uses by 
 default the 'tui' the 'tui' container spec from k8s-tools.yml.
```

 
#### **`tux.mux/<arg>`**


```bash 
Maps execution for each of the comma-delimited targets 
 into separate panes of a tmux (actually 'tmuxp') session.

 USAGE:
   ./compose.mk tux.mux/<target1>,<target2>
```

 
#### **`tux.pane/<arg>`**


```bash 
Remote control for the TUI, from the host, running the given target.

 USAGE:
   ./compose.mk tux.pane/1/<target_name>
```

 
#### **`tux.panic`**


```bash 
USAGE:
  ./compose.mk tui.panic
```

 
#### **`tux.ps`**


```bash 
Lists ID's for containers related to the TUI.

 USAGE:
  ./compose.mk tux.ps
```

 
#### **`tux.stream.split`**


```bash 

```

 
#### **`tux.widget.ticker`**


```bash 
A ticker-style display for the given text, suitable for usage with tmux status bars,
 in case the full text won't fit in the space available. Like most TUI widgets, 
 this loops forever, but unlike most it is pure bash, no ncurses/tmux reqs.

 USAGE:
   text=mytext ./compose.mk tux.widget.ticker
```

 
#### **`tux/shell`**


```bash 
Bridge compatability.

 USAGE:
  ./compose.mk tux/shell
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: io

The *`io.*`* targets cover various I/O helpers, text-formatters, and other utilities.




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`io.bash`**


```bash 
Starts an interactive shell with all the environment variables set 
 by the parent environment, plus those set by this Makefile context.
```

 
#### **`io.env`**


```bash 
Dumps a relevant subset of environment variables for the current context.
 No arguments.  Pipe-safe since this is just filtered output from 'env'.

 USAGE:
   ./compose.mk io.env
```

 
#### **`io.env.filter.prefix/<arg>`**

 
* *Alias for [`io.env/<arg>`](#ioenvarg)*

 
#### **`io.env.pretty`**


```bash 
Pretty version of io.env, this includes some syntax highlighting.
 No arguments.  See 'io.envp/<arg>' for a version that supports filtering.

 USAGE:
  ./compose.mk io.envp
```

 
#### **`io.env.pretty/<arg>`**

 
* *Alias for [`io.envp/<arg>`](#ioenvparg)*

 
#### **`io.env/<arg>`**


```bash 
Filters environment variables by the given prefix or (comma-delimited) prefixes.

 USAGE:
   ./compose.mk io.env/<prefix1>,<prefix2>
```

 
#### **`io.envp`**


```bash 
Pretty version of io.env, this includes some syntax highlighting.
 No arguments.  See 'io.envp/<arg>' for a version that supports filtering.

 USAGE:
  ./compose.mk io.envp
```

 
#### **`io.envp/<arg>`**


```bash 
Pretty version of 'io.env/<arg>', this includes syntax highlighting and also filters the output.

 USAGE:
  ./compose.mk io.envp/<prefix_to_filter_for>

 USAGE: (only vars matching 'TUI*')
  ./compose.mk io.envp/TUI

 USAGE: (only vars matching 'COMPOSE*')
  ./compose.mk io.envp/COMPOSE
```

 
#### **`io.file.preview/<arg>`**


```bash 
Outputs syntax-highlighting + line-numbers for the given filename to stderr.

 USAGE:
  ./compose.mk io.file.preview/<fname>
```

 
#### **`io.file.pygmentize/<arg>`**


```bash 
Syntax highlighting for the given file.
 Lexer will autodetected unless override is provided.  
 Style defaults to 'trac', which works best with dark backgrounds.

 USAGE:
   ./compose.mk io.file.pygmentize/<fname>
   lexer=.. ./compose.mk io.file.pygmentize/<fname>
   lexer=.. style=.. ./compose.mk io.file.pygmentize/<fname>

 REFS:
 [1]: https://hub.docker.com/r/backplane/pygmentize
 [2]:https://pygments.org/styles/
```

 
#### **`io.fmt.strip`**


```bash 
Pipe-friendly helper for stripping whitespace.
```

 
#### **`io.help`**


```bash 
Lists only the targets available under the 'io' namespace.
```

 
#### **`io.print.div`**


```bash 
Prints a divider on stdout, defaulting to the full terminal width, 
 with optional label.  This automatically detects console width, but
 it requires 'tput' (usually part of a 'ncurses' package).

 USAGE: 
  ./compose.mk io.print.div label=".." filler=".." width="..."
```

 
#### **`io.print.div/<arg>`**


```bash 
Prints a divider with a width of `term_width / <arg>`

 USAGE: (half-width labelled divider)
  label.. ./compose.mk io.print.div/<int>
```

 
#### **`io.print.indent`**


```bash 
Pipe-friendly helper for indention; reads from stdin and returns indented result on stdout

 USAGE:
```

 
#### **`io.print.indent.stderr`**


```bash 
USAGE:
```

 
#### **`io.quiet.stderr.sh`**


```bash 
Runs the given target, surpressing stderr output, except in case of error.

 USAGE: 
  ./compose.mk io.quiet/<target_name>
```

 
#### **`io.quiet.stderr/<arg>`**


```bash 
Runs the given target, surpressing stderr output, except in case of error.

 USAGE: 
  ./compose.mk io.quiet/<target_name>
```

 
#### **`io.tail/<arg>`**


```bash 
Tails the named file, creating it first if necessary.
 This is always blocking and won't throw an error even if the file doesn't exist.

 USAGE:
  ./compose.mk io.tail/<fname>
```

 
#### **`io.time.wait`**


```bash 
Pauses for 1 second.
```

 
#### **`io.time.wait/<arg>`**


```bash 
Pauses for the given amount of seconds.

 USAGE: 
   ./compose.mk io.time.wait/<int>
```

 
#### **`io.time.wait/1`**


```bash 

```

 
#### **`io.wait/<arg>`**

 
* *Alias for [`io.time.wait/<arg>`](#iotimewaitarg)*



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: docker

The *`docker.*`* targets cover a few helpers for working with docker.  This interface is deliberately minimal, focusing on verbs like 'stop' and 'stat' more than verbs like 'build' and 'run'.  That's because containers that are managed by `docker compose` are preferred, but for simple use-cases it's nice to avoid an almost-empty service definition.  See [`stream.pygmentize`](#streampygmentize) for an example.




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`docker.commander`**


```bash 
TUI layout providing an overview for docker.  
 This has 3 panes by default, where the main pane is lazydocker, plus two utility panes.
 Automation also ensures that lazydocker always starts with the "statistics" tab open.
```

 
#### **`docker.context`**


```bash 
Returns all of the available docker context. Pipe-friendly.
```

 
#### **`docker.context/<arg>`**


```bash 
Returns docker-context details for the given context-name.  
 Pipe-friendly; outputs JSON from 'docker context inspect'

 USAGE: (shortcut for the current context name)
  ./compose.mk docker.context/current 

 USAGE: (using named context)
  ./compose.mk docker.context/<context_name>
```

 
#### **`docker.from.def/<arg>`**


```bash 
Builds a container, treating the given 'define' block as a Dockerfile.
 This is part of the mad-science[1] test-suite and not really a good idea =P

 USAGE: 
   make docker.Dockerfile/<my_def_name>
   tag=<my_tag> make docker.Dockerfile/<my_def_name>

 REFS:
  [1]: https://github.com/elo-enterprises/k8s-tools/blob/master/tests/Makefile.mad-science.mk
```

 
#### **`docker.help`**


```bash 
Lists only the targets available under the 'docker' namespace.
```

 
#### **`docker.init`**


```bash 
Checks if docker is available, then displays version/context (no real setup)
```

 
#### **`docker.init.compose`**


```bash 
Ensures compose is available.  Note that 
 build/run/etc cannot happen without a file, 
 for that, see instead targets like '<compose_file_stem>.build'
```

 
#### **`docker.panic`**


```bash 
Debugging only!  This is good for ensuring a clean environment, 
 but running this from automation will nix your cache of downloaded
 images, and so you will probably quickly hit rate-limiting at dockerhub.  
 It tears down volumes and networks also, so you don't want to run this in prod.
```

 
#### **`docker.panic.network`**


```bash 
Runs 'docker network prune' for the entire system.
```

 
#### **`docker.panic.prune`**


```bash 
Runs 'docker system prune' for the entire system.
```

 
#### **`docker.panic.volume`**


```bash 
Runs 'docker volume prune' for the entire system.
```

 
#### **`docker.ps`**


```bash 
Like 'docker ps', but always returns JSON.
```

 
#### **`docker.run.script/<arg>`**


```bash 
Treats the named 'define' as a script, then runs it inside the given container.
 This automatically detects whether input should be treated as a pipe.

 USAGE:
  ./compose.mk docker.run.script/<def_name>/<image>
```

 
#### **`docker.run.sh/<arg>`**


```bash 
Runs the given command inside the named container.

 This automatically detects whether it's used as a pipe & proxies stdin as appropriate.
 This always shares the working directory as a volume & uses that as a workspace.

 USAGE:
   ./compose.mk docker.run.sh/<image_tag> cmd=...
```

 
#### **`docker.run/<arg>`**


```bash 
Runs the named target inside the named docker container.

 USAGE:
  ./compose.mk docker.run/<image>/<target>
```

 
#### **`docker.socket`**


```bash 
Returns the docker socket in use for the current docker context.
 No arguments & pipe-friendly.
```

 
#### **`docker.stat`**


```bash 
Show information about docker-status.  No arguments.

 This is pipe-friendly, although it also displays additional 
 information on stderr for humans, specifically an abbreviated
 table for 'docker ps'.  Machine-friendly JSON is also output 
 with the following schema:

   { "version": .., "container_count": ..,
     "socket": .., "context_name": .. }
```

 
#### **`docker.stop`**


```bash 
Stops one container, using the given timeout and the given id or name.

 USAGE:
   ./compose.mk docker.stop id=8f350cdf2867 
   ./compose.mk docker.stop name=my-container 
   ./compose.mk docker.stop name=my-container timeout=99
```

 
#### **`docker.stop.all`**


```bash 
Non-graceful stop for all containers.

 USAGE:
   ./compose.mk docker.stop name=my-container timeout=99
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: flux

The *`flux.*`* targets describe a miniature workflow library.  

Combining `flux` with [container dispatch](#container-dispatch) is similar in spirit to things like [declarative pipelines in Jenkins](https://www.jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline), but simpler, more portable, and significantly easier to use.  

The focus for these targets is on join/loop/map operations *over other make targets*, taking inspiration from functional programming and threading libraries.  For stuff that's more specific to shell code, see`flux.sh.*`, and for working with scripts see `flux.script.*`.  See also the [Platform Setup Example](#demo-platform-setup) for a more complete walk-through of motivation/use-case.




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`flux.always/<arg>`**

 
* *Alias for [`flux.finally/<arg>`](#fluxfinallyarg)*

 
#### **`flux.apply.later.sh/<arg>`**


```bash 
Applies the given command at some point in the future.  This is non-blocking.
 Not pipe-safe, because since targets run in the background, this can garble your display!
 
 USAGE:
   cmd="..." ./compose.mk flux.apply.later.sh/<seconds>
```

 
#### **`flux.apply.later/<arg>`**


```bash 
Applies the given targets at some point in the future.  This is non-blocking.
 Not pipe-safe, because since targets run in the background, this can garble your display!
 
 USAGE:
   ./compose.mk flux.apply.later/<seconds>/<target>
```

 
#### **`flux.apply/<arg>`**


```bash 
Applies the given target(s). Mostly used to as a wrapper in case targets are unary.
 
 USAGE:
   ./compose.mk flux.timer/flux.apply/io.time.wait,io.time.wait
```

 
#### **`flux.delay/<arg>`**

 
* *Alias for [`flux.apply.later/<arg>`](#fluxapplylaterarg)*

 
#### **`flux.dmux`**


```bash 
Demultiplex / fan-out operator that sends stdin to each of the named targets in parallel.
 (This is like `flux.sh.tee` but works with make-target names instead of shell commands)

 USAGE: (pipes the same input to target1 and target2)
   echo {} | ./compose.mk flux.dmux targets=",target2"
```

 
#### **`flux.dmux/<arg>`**


```bash 
Same as flux.dmux, but accepts arguments directly (no variable)
 Stream-usage is required (this blocks waiting on stdin).

 USAGE: ( pipes the same input to yq and jq )
   echo {} | ./compose.mk flux.dmux/yq,jq
```

 
#### **`flux.fail`**


```bash 
Alias for 'exit 1', which is failure.
 This is mostly for used for testing other pipelines.

 See also the 'flux.ok' target.
```

 
#### **`flux.finally/<arg>`**


```bash 
Always run the given target, even if the rest of the pipeline fails.


 NB: For this to work, the `always` target needs to be declared at the 
 beginning.  See the example below where "<target>" always runs, even 
 though the pipeline fails in the middle.

 USAGE: 
   ./compose.mk flux.always/<target_name> flux.ok flux.fail flux.ok
```

 
#### **`flux.help`**


```bash 
Lists only the targets available under the 'flux' namespace.
```

 
#### **`flux.indent.sh`**


```bash 
Similar to flux.indent, but this works with any shell command.
 
 USAGE:
  cmd="echo foo; echo bar >/dev/stderr" ./compose.mk flux.indent.sh
```

 
#### **`flux.indent/<arg>`**


```bash 
Given a target, this runs it and indents both the resulting output for both stdout/stderr.
 See also the 'stream.indent' target.

 USAGE:
   ./compose.mk flux.indent/<target>
```

 
#### **`flux.join`**


```bash 
Runs the given comma-delimited targets in parallel, then waits for all of them to finish.
 For stdout and stderr, this is a many-to-one mashup of whatever writes first, and nothing   
 about output ordering is guaranteed.  This works by creating a small script, displaying it, 
 and then running it.  It's not very sophisticated!  The script just tracks pids of 
 launched processes, then waits on all pids.
 
 If the named targets are all well-behaved, this *might* be pipe-safe, but in 
 general it's possible for the subprocess output to be out of order.  If you do
 want *legible, structured output* that *prints* in ways that are concurrency-safe,
 here's a hint: emit nothing, or emit minified JSON output with printf and 'jq -c',
 and there is a good chance you can consume it.  Printf should be atomic on most 
 platforms with JSON of practical size? And crucially, 'jq .' handles object input, 
 empty input, and streamed objects with no wrapper (like '{}<newline>{}').

 USAGE: (runs 3 commands in parallel)
   ./compose.mk flux.mux targets="io.time.wait/3,io.time.wait/1,io.time.wait/2" | jq .
```

 
#### **`flux.loop/<arg>`**


```bash 
Helper for repeatedly running the named target a given number of times.
 This requires the 'pv' tool for progress visualization, which is available
 by default in k8s-tools containers.   By default, stdout for targets is 
 supressed because it messes up the progress bar, but stderr is left alone. 

 USAGE:
   ./compose.mk flux.loop/<times>/<target_name>

 NB: This requires "flat" targets with no '/' !
```

 
#### **`flux.loopf/<arg>`**


```bash 
Loops the given target forever.

 By default to reduce logging noise, this sends stderr to null, but preserves stdout. 
 This makes debugging hard, so only use this with well tested/understood sub-targets,
 or set "verbose=1" to allow stderr.  When "quiet=1" is set, even more logging is trimmed.

 USAGE:
```

 
#### **`flux.loopfq/<arg>`**


```bash 
Like flux.loopf, but even more quiet.
```

 
#### **`flux.loopu/<arg>`**


```bash 
Loop the given target until it succeeds.

 By default to reduce logging noise, this sends stderr to null, but preserves stdout. 
 This makes debugging hard, so only use this with well tested/understood sub-targets,
 or set "verbose=1" to allow stderr.  When "quiet=1" is set, even more logging is trimmed.

 USAGE:
```

 
#### **`flux.loopw/<arg>`**


```bash 
Loops the given target forever, using 'watch' instead of the while-loop default
```

 
#### **`flux.map/<arg>`**


```bash 
Similar to 'flux.apply', but maps input stream sequentially onto the comma-delimited target list.

 USAGE:
   echo hello-world | ./compose.mk flux.map/stream.echo,stream.echo
```

 
#### **`flux.mux`**


```bash 
Runs the given comma-delimited targets in parallel, then waits for all of them to finish.
 For stdout and stderr, this is a many-to-one mashup of whatever writes first, and nothing   
 about output ordering is guaranteed.  This works by creating a small script, displaying it, 
 and then running it.  It's not very sophisticated!  The script just tracks pids of 
 launched processes, then waits on all pids.
 
 If the named targets are all well-behaved, this *might* be pipe-safe, but in 
 general it's possible for the subprocess output to be out of order.  If you do
 want *legible, structured output* that *prints* in ways that are concurrency-safe,
 here's a hint: emit nothing, or emit minified JSON output with printf and 'jq -c',
 and there is a good chance you can consume it.  Printf should be atomic on most 
 platforms with JSON of practical size? And crucially, 'jq .' handles object input, 
 empty input, and streamed objects with no wrapper (like '{}<newline>{}').

 USAGE: (runs 3 commands in parallel)
   ./compose.mk flux.mux targets="io.time.wait/3,io.time.wait/1,io.time.wait/2" | jq .
```

 
#### **`flux.mux/<arg>`**


```bash 
Alias for flux.mux, but accepts arguments directly
```

 
#### **`flux.ok`**


```bash 
Alias for 'exit 0', which is success.
 This is mostly for used for testing other pipelines.  See also 'flux.fail'
```

 
#### **`flux.retry/<arg>`**


```bash 
Retries the given target a certain number of times.

 USAGE: (using default interval of 'K8S_POLL_DELTA')
   ./compose.mk flux.retry/<times>/<target> 

 USAGE: (explicit interval in seconds)
   interval=3 ./compose.mk flux.retry/<times>/<target>
```

 
#### **`flux.sh.tee`**


```bash 
Helper for constructing a parallel process pipeline with `tee` and command substitution.
 Pipe-friendly, this works directly with stdin.  This exists mostly to enable `flux.dmux`
 but it can be used directly.

 Using this is easier than the alternative pure-shell version for simple commands, but it's 
 also pretty naive, and splits commands on commas; probably better to avoid loading other
 pipelines as individual commands with this approach.  

 USAGE: ( pipes the same input to 'jq' and 'yq' commands )
   echo {} | ./compose.mk flux.sh.tee cmds="jq,yq"
```

 
#### **`flux.split`**


```bash 
Demultiplex / fan-out operator that sends stdin to each of the named targets in parallel.
 (This is like `flux.sh.tee` but works with make-target names instead of shell commands)

 USAGE: (pipes the same input to target1 and target2)
   echo {} | ./compose.mk flux.dmux targets=",target2"
```

 
#### **`flux.split/<arg>`**


```bash 
Alias for flux.split, but accepts arguments directly
```

 
#### **`flux.stage.require/<arg>`**


```bash 
Asserts that the given stage should have been already entered.
```

 
#### **`flux.stage/<arg>`**


```bash 
Declares entry for the given stage.
```

 
#### **`flux.timeout.sh`**


```bash 
Runs the given command for the given amount of seconds, then stops it with SIGINT.

 USAGE: (tails docker logs for up to 10s, then stops)
   ./compose.mk flux.timeout.sh cmd='docker logs -f xxxx' timeout=10
```

 
#### **`flux.timeout/<arg>`**


```bash 
Runs the given target for the given number of seconds, then stops it with SIGINT.

 USAGE: 
   ./compose.mk flux.timeout/<seconds>/<target>
```

 
#### **`flux.timer/<arg>`**


```bash 
Emits run time for the given make-target in seconds.
 Pipe safe; target stdout is sent to stderr.

 USAGE:
   ./compose.mk flux.timer/<target_to_run>
```

 
#### **`flux.wrap/<arg>`**


```bash 
Wraps all of the given targets as if it were a single target.
 This allows using multiple targets anywhere that unary targets are supported.

 USAGE:
   ./compose.mk flux.timer/flux.wrap/io.time.wait,io.time.wait
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: gum

The `gum.*` targets support usage of [charmbracelet/gum](#).  These targets generally use gum natively if available, falling back to using [tux](#api-tux).  See also [`io.print.*`](#api-io).




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`gum.dispatch`**


```bash 
Runs a command that's using gum.  See 'gum.style' for example usage.
 This happens on the host if possible, falling back to the 'compose.mk:tux' container otherwise.
```

 
#### **`gum.label/<arg>`**


```bash 

```

 
#### **`gum.spin`**


```bash 
USAGE:
   cmd=.. title=.. ./compose.mk gum.spin

 REFS:
 [1] https://github.com/charmbracelet/gum for more details.
```

 
#### **`gum.style`**


```bash 
Helper for formatting text and banners using 'gum style' and 'gum format'.
 Expects label text under the 'label' variable, plus supporting optional 'width'.
 Labels automatically go through 'gum format' before 'gum style', so templates are supported.

 REFS:
 [1] https://github.com/charmbracelet/gum for more details.

 USAGE:
   ./compose.mk gum.style label="..."
   ./compose.mk gum.style width=30 label='{{Bold "bonk"}}'
```

 
#### **`gum.style/<arg>`**


```bash 
Prints a divider on stdout for the given fraction of the full terminal width, 
 with given label.  This automatically detects console width, but
 it requires 'tput' (usually part of a 'ncurses' package).

 USAGE: (A half-width labeled divider)
   label=... make gum.style/2
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: stream

The `stream.*` targets support IO streams, including basic stuff with JSON, newline-delimited, and space-delimited formats.




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`stream.comma.to.json`**


```bash 
Converts comma-delimited input into minimized JSON array

 USAGE:
   echo 1,2,3 | ./compose.mk stream.comma.to.json
   ["1","2","3"]
```

 
#### **`stream.comma.to.nl`**


```bash 
Converts comma-delimited input stream newline-delimited
```

 
#### **`stream.csv.pygmentize`**


```bash 

```

 
#### **`stream.dim`**


```bash 
Pipe-friendly helper for dimming the input text
```

 
#### **`stream.dim.indent`**


```bash 
Like 'io.print.indent' except it also dims the text.
```

 
#### **`stream.dim.indent.stderr`**


```bash 

```

 
#### **`stream.echo`**


```bash 
Just echoes the input stream.  Mostly used for testing.

 USAGE:
   echo hello-world | ./compose.mk stream.echo
```

 
#### **`stream.help`**


```bash 
Lists only the targets available under the 'stream' namespace.
```

 
#### **`stream.indent`**


```bash 
Indents input stream
```

 
#### **`stream.indent.to.stderr`**


```bash 
Shortcut for ' | stream.indent | stream.to.stderr'
```

 
#### **`stream.json.array.append`**


```bash 
Appends <val> to input array
 
 USAGE:
   echo '[]'|val=1 ./compose.mk stream.json.array.append|val=2 make stream.json.array.append
   [1,2]
```

 
#### **`stream.json.object.append`**


```bash 
Appends the given key/val to the input object.
 This is usually used to build JSON objects from scratch.

 USAGE: 
	 echo {} | key=foo val=bar ./compose.mk stream.json.object.append 
   {"foo":"bar"}
```

 
#### **`stream.nl.enum`**


```bash 
Enumerates the newline-delimited input stream, zipping index with values

 USAGE:
   printf "one\ntwo" | ./compose.mk stream.nl.enum
 		0	one
 		1	two
```

 
#### **`stream.nl.to.json.array`**


```bash 
Converts newline-delimited input stream into a JSON array
```

 
#### **`stream.peek`**


```bash 
Prints the entire input stream as indented/dimmed text on stderr,
 Then passes-through the entire stream to stdout.

 USAGE:
   echo hello-world | ./compose.mk stream.peek | cat
```

 
#### **`stream.preview`**


```bash 
Previews the input stream, sending output to stderr.  
 Alias for stream.to.stderr.
```

 
#### **`stream.pygmentize`**


```bash 
Syntax highlighting for the input stream.

 https://hub.docker.com/r/backplane/pygmentize
 https://pygments.org/styles/
```

 
#### **`stream.space.enum`**


```bash 
Enumerates the space-delimited input list, zipping indexes with values.

 USAGE:
   printf one two | ./compose.mk io.enum
 		0	one
 		1	two
```

 
#### **`stream.split.view`**


```bash 

```

 
#### **`stream.stderr.indent`**


```bash 
Indents the input stream, writing output to stderr
```

 
#### **`stream.to.stderr`**


```bash 
Sends input stream to stderr.
 Unlike 'stream.peek', this does not pass on the input stream.
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">


----------------------------------------------------

##### TUI Private API

The [public API for `tux.*` targets](/docs/api#api-tux) describes several lower-level operations that can safely be performed inside or outside of the TUI (i.e. on the docker host).

There's also a "private" API, which targets are under the namespace `.tux.*`, and which is characterized by actually issuing commands to tmux directly.  The private API is intended to be used from *inside* the `tux` container or containers that extend it.  This ensures that your host doesn't actually require a tmux stack, and also ensures that usage of the TUI is always relatively stateless.  (It's not extensively tested yet, but in theory it should be generally safe to run multiple copies of the TUI, and embed TUIs in TUIs, etc.)

See the [API docs](/docs/api#tui-private-api)




*This documentation is pulled automatically from [source](compose.mk).*

 
#### **`.tux.attach`**


```bash 

```

 
#### **`.tux.bootstrap`**


```bash 
Private helper for tux.bootstrap
```

 
#### **`.tux.commander.layout`**


```bash 
Configures a custom geometry on up to 4 panes.
 This has a large central window and a sidebar.
```

 
#### **`.tux.dwindle/<arg>`**

 
* *Alias for [`.tux.layout/<arg>`](#tuxlayoutarg)*

 
#### **`.tux.dwindle/h`**


```bash 

```

 
#### **`.tux.dwindle/s`**


```bash 

```

 
#### **`.tux.geo.get`**


```bash 
Gets the current geometry for tmux.  No arguments.
 Output format is suitable for use with '.tux.geo.set' so that you can save manual changes.

 USAGE:
  ./compose.mk .tux.geo.get
```

 
#### **`.tux.geo.set`**


```bash 
Sets tmux geometry from 'geometry' environment variable.

 USAGE:
   geometry=... ./compose.mk .tux.geo.set
```

 
#### **`.tux.img.display/<arg>`**


```bash 
Displays the named file using chafa, and centering it in the available terminal width.

 USAGE:
  ./compose.mk .tux.img.display/<fname>
```

 
#### **`.tux.init`**


```bash 
Initialization for the TUI (a tmuxinator-managed tmux instance).
 This needs to be called from inside the TUI container, with tmux already running.

 Typically this is used internally during TUI bootstrap, but you can call this to 
 rexecute the main setup for things like default key-bindings and look & feel.
```

 
#### **`.tux.init.bind_keys`**


```bash 
Private helper for .tux.init.  
 (This bind default keys for pane resizing, etc)
```

 
#### **`.tux.init.buttons`**


```bash 
Generates tmux-script that configures the buttons for "New Pane" and "Exit".
 This isn't called directly, but is generally used as the post-theme setup hook.  
 See also 'TUI_THEME_HOOK_POST'
```

 
#### **`.tux.init.panes`**


```bash 
Private helper for .tux.init.  (This fixes a bug in tmuxp with pane titles)
```

 
#### **`.tux.init.status_bar`**


```bash 
Stuff that has to be set before importing the theme
```

 
#### **`.tux.init.theme`**


```bash 
This configures a green theme for the statusbar.
 The tmux themepack green theme is actually yellow!

 REFS:
   [1] Colors at https://www.ditig.com/publications/256-colors-cheat-sheet
   [2] Gallery at https://github.com/jimeh/tmux-themepack
```

 
#### **`.tux.layout.dwindle/<arg>`**

 
* *Alias for [`.tux.layout/<arg>`](#tuxlayoutarg)*

 
#### **`.tux.layout.horizontal`**


```bash 
Alias for the horizontal layout.  
 See '.tux.dwindle' docs for more info
```

 
#### **`.tux.layout.spiral`**


```bash 
Alias for the dwindle spiral layout.  
 See '.tux.dwindle' docs for more info
```

 
#### **`.tux.layout/<arg>`**


```bash 
Sets geometry to the given layout, using tmux-layout-dwindle.
 This is installed by default in k8s-tools.yml / k8s:tui container.

 See [1] for general docs and discussion of options.

 [1] https://raw.githubusercontent.com/sunaku/home/master/bin/tmux-layout-dwindle

 USAGE:
   ./compose.mk .tux.layout/<layout_code>
```

 
#### **`.tux.msg`**


```bash 
Flashes a message on the tmux UI.
```

 
#### **`.tux.pane.focus/<arg>`**


```bash 
Focuses the given pane.  This always assumes we're using the first tmux window.
 
 USAGE: (focuses pane #1)
  ./compose.mk .tux.pane.focus/1
```

 
#### **`.tux.pane.sh/<arg>`**


```bash 
Runs command on the given tmux pane with the given ID.
 (Like '.tux.pane' but works with a generic shell command instead of a target-name.)  

 USAGE:
   cmd="echo hello tmux pane" ./compose.mk .tux.pane.sh/<pane_id>
```

 
#### **`.tux.pane.title/<arg>`**


```bash 
Sets the title for the given pane.

 USAGE:
   title=hello-world ./compose.mk .tux.pane.title/<pane_id>
```

 
#### **`.tux.pane/<arg>`**


```bash 
Dispatches the given make-target to the tmux pane with the given id.

 USAGE:
   ./compose.mk .tux.pane/<pane_id>/<target_name>
```

 
#### **`.tux.panes/<arg>`**


```bash 
This generates the tmuxp panes data structure (a JSON array) from comma-separated target list.
 (Used internally when bootstrapping the TUI, regardless of what the TUI is running.)
```

 
#### **`.tux.panic`**


```bash 
Closes the entire session, from inside the session.  No arguments.  
 This is used by the 'Exit' button in the main status-bar.
 See also 'tux.panic', which can be used from the docker host, and which stops *all* sessions.
```

 
#### **`.tux.stream.split`**


```bash 

```

 
#### **`.tux.stream.split.layout`**


```bash 

```

 
#### **`.tux.theme`**


```bash 
Setup for the TUI's tmux theme.  

 This does nothing directly, and just honors the environment's settings 
 for TUI_THEME_NAME, TUI_THEME_HOOK_PRE, & TUI_THEME_HOOK_POST
```

 
#### **`.tux.theme.set/<arg>`**


```bash 
Sets the named theme for current tmux session.  

 Requires themepack [1] (installed by default with compose.mk:tux container)

 USAGE:
   ./compose.mk .tux.theme.set/powerline/double/cyan

 [1]: https://github.com/jimeh/tmux-themepack.git
 [2]: https://github.com/tmux/tmux/wiki/Advanced-Use
```

 
#### **`.tux.widget.env`**


```bash 
Pretty version of io.env, this includes some syntax highlighting.
 No arguments.  See 'io.envp/<arg>' for a version that supports filtering.

 USAGE:
  ./compose.mk io.envp
```

 
#### **`.tux.widget.env/<arg>`**

 
* *Alias for [`io.envp/<arg>`](#ioenvparg)*

 
#### **`.tux.widget.img`**


```bash 
Displays the given image URL or file-path forever, as a TUI widget.  
 This functionality requires a loop, otherwise chafa won't notice or adapt 
 to any screen or pane resizing.  In case of a URL, it is downloaded 
 only once at startup.

 USAGE:
   url=... make .tux.widget.img
   path=... make .tux.widget.img
 
 Besides supporting proper URLs, this works with file-paths.  
 The path of course needs to exist and should actually point at an image.
```

 
#### **`.tux.widget.img.var/<arg>`**


```bash 
Unpacks an image URL from the given make/shell variable name, then displays it as TUI widget.

 The variable of course needs to exist and should actually point at an image.  
 Besides supporting proper URLs, this works with file-paths.  See '.tux.widget.img'

 USAGE:
  ./compose.mk .tux.widget.img.var/<var_name>
```

 
#### **`.tux.widget.lazydocker`**


```bash 

```

 
#### **`.tux.widget.lazydocker/<arg>`**


```bash 
Starts lazydocker in the TUI, then switches to the "statistics" tab.
```

 
#### **`.tux.widget.lazydocker/1`**


```bash 

```

 
#### **`.tux.widget.ticker`**


```bash 
A ticker-style display for the given text, suitable for usage with tmux status bars,
 in case the full text won't fit in the space available. Like most TUI widgets, 
 this loops forever, but unlike most it is pure bash, no ncurses/tmux reqs.

 USAGE:
   text=mytext ./compose.mk tux.widget.ticker
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

----------------------------------------------------

### API: k8s.mk: (Static Targets)

This is the complete list of namespaces & targets available from k8s.mk, along with their documentation.  Most documentation is pulled automatically from [the latest source](compose.mk). First, some important notes about how these targets work.

The best way to use these targets is in combination with `compose.mk` and `k8s-tools.yml`, following the [makefile integration docs](#embedding-tools-with-makefiles).  See also the docs for the [Make/Compose Bridge](#makecompose-bridge) and [Container Dispatch](#container-dispatch).

Still, many of these targets can run "natively" if your host already has the relevant tools, and some targets like `k8s.shell` can default to using containers if present, then fall-back to using kubectl directly.

Target names are reserved names after declaration, but collisions aren't likely because things are organized into a few namespaces:

1. You'll need to have setup KUBECONFIG before running most of these
1. Targets are usable interactively from your shell as `make <target>` or `k8s.mk <target>`
1. Targets are usable as an API, either as target prereqs or as part of the body in your targets

* **Most targets depend on compose.mk.** When used in stand-alone mode, k8s.mk will attempt to import compose.mk from the same directory.
* **Most targets have a soft-requirement k8s-tools.yml.** This isn't always a hard-requirement if you have tools like `kubectl` available already on the docker-host.
* **Targets are usable interactively from your shell** as `make <target>` or `./k8s.mk <target>`.  If you use k8s.mk directly here, you need to set vars like `KUBECONFIG` yourself instead of relying on your project Makefile to set them up.
* **Targets are usable as an API,** either as prereq-targets or as part of the body in your targets.
* **Target names are reserved names after declaration.**

Things are organized into a few namespaces, which hopefully avoids collisions with your project targets.

* [k8s.* targets:](/docs/api#api-k8s) Default namespace with general helpers.  These targets only use things available in the [k8s:base container](k8s.yml).
* [k3d.* targets:](/docs/api#api-k3d):  Helpers for working with the `k3d` tool / container
* [kubefwd.* targets:](/docs/api#api-kubefwd) Helpers for working with `kubefwd` tool / container
* [helm.* targets:](/docs/api#api-helm) Helpers for working with `helm` tool / container




#### API: k8s

This is the default target-namespace for `k8s.mk`.  It covers general helpers.  For more details, read on into the API, or see the [k8s:base container spec in k8s-tools.yml](
https://github.com/search?q=repo%3Aelo-enterprises%2Fk8s-tools+path%3Ak8s-tools.yml+content%3Ak8s%3Abase&type=code)




*This documentation is pulled automatically from [source](k8s.mk).*

 
#### **`k8s.cluster.wait`**


```bash 
Waits until all pods in all namespaces are ready.  (Alias for 'k8s.namespace.wait/all')
```

 
#### **`k8s.commander`**


```bash 
TUI layout providing an overview for docker.  
 This has 3 panes by default, where the main pane is lazydocker, plus two utility panes.
 Automation also ensures that lazydocker always starts with the "statistics" tab open.
```

 
#### **`k8s.commander/<arg>`**


```bash 
Sends the given target(s) to the main pane.

 USAGE:
   ./k8s.mk k8s.commander/<target1>,<target2>
```

 
#### **`k8s.get/<arg>`**


```bash 
Returns resources under the given namespace, for the given kind.
 This can also be used with a 'jq' query to grab deeply nested results.
 Pipe Friendly: results are always JSON.  Caller should handle errors.

 USAGE: 
	 ./k8s.mk k8s.get/<namespace>/<kind>/<resource_name>/<jq_filter>

 Argument for 'kind' must be provided, but may be "all".  
 Argument for 'filter' is optional.
```

 
#### **`k8s.graph`**


```bash 

```

 
#### **`k8s.graph.tui`**


```bash 

```

 
#### **`k8s.graph.tui.loop`**


```bash 
Loops the graph for the kube-system namespace
```

 
#### **`k8s.graph.tui.loop/<arg>`**


```bash 
Display an updating, low-resolution image of the given namespace topology.

 USAGE:  
   ./k8s.mk k8s.graph.tui.loop/<namespace>
```

 
#### **`k8s.graph.tui.loop/kube-system/pods`**


```bash 

```

 
#### **`k8s.graph.tui/<arg>`**


```bash 
Previews topology for a given kubernetes <namespace>/<kind> in a way that's terminal-friendly.

 This is a human-friendly way to visualize progress or changes, because it supports 
 very large input data from complex deployments with lots of services/pods, either in 
 one namespace or across the whole cluster. To do that, it has throw away some 
 information compared with raw kubectl output, and node labels on the graph aren't visible.  

 This is basically a pipeline from graphs in dot format, 
 generated by kubectl-graph, then passed through some image-magick 
 transformations, and then pushed into the 'chafa' tool for 
 generating ASCII-art from images.

 USAGE: (same as k8s.graph)
   ./k8s.mk k8s.graph.tui/<namespace>/<kind>
```

 
#### **`k8s.graph.tui/all/pods`**


```bash 

```

 
#### **`k8s.graph/<arg>`**


```bash 
Graphs resources under the given namespace, for the given kind, in dot-format.
 Pipe Friendly: results are always dot files.  Caller should handle any errors.

 This requires the krew plugin "graph" (installed by default with k8s-tools.yml).

 USAGE: 
	 ./k8s.mk k8s.graph/<namespace>/<kind>/<field_selector>

 Argument for 'kind' must be provided, but may be "all".  
 Argument for field-selector is optional.  (Default value is 'status.phase=Running')
```

 
#### **`k8s.graph/all/pods`**


```bash 

```

 
#### **`k8s.help`**


```bash 
Shows targets for just the 'k8s' namespace.
```

 
#### **`k8s.kubens.create/<arg>`**


```bash 
Context-manager.  Activates the given namespace, creating it first if necessary.

 NB: This modifies state in the kubeconfig, so that it can effect contexts 
 outside of the current process, therefore this is not thread-safe.

 USAGE: 
    ./k8s.mk k8s.kubens.create/<namespace>
```

 
#### **`k8s.kubens/<arg>`**


```bash 
Context-manager.  Activates the given namespace.
 NB: This modifies state in the kubeconfig, so that it can effect contexts 
 outside of the current process, therefore this is not thread-safe.

 USAGE:  
   ./k8s.mk k8s.kubens/<namespace>
```

 
#### **`k8s.namespace.create/<arg>`**


```bash 
Idempotent version of namespace-create

 USAGE: 
    k8s.namespace.create/<namespace>
```

 
#### **`k8s.namespace.fwd/<arg>`**

 
* *Alias for [`kubefwd.start/<arg>`](#kubefwdstartarg)*

 
#### **`k8s.namespace.list`**


```bash 
Returns all namespaces in a simple array.
 NB: Must remain suitable for use with `xargs`!
```

 
#### **`k8s.namespace.purge.by.prefix/<arg>`**


```bash 
Runs a separate purge for every matching namespace.
 NB: This isn't likely to clean everything, see the docs for your dependencies.

 USAGE: 
    ./k8s.mk k8s.namespace.purge.by.prefix/<prefix>
```

 
#### **`k8s.namespace.purge/<arg>`**


```bash 
Wipes everything inside the given namespace

 USAGE: 
    k8s.namespace.purge/<namespace>
```

 
#### **`k8s.namespace.wait/<arg>`**


```bash 
Waits for every pod in the given namespace to be ready.

 This uses only kubectl/jq to loop on pod-status, but assumes that 
 the krew-plugin 'sick-pods'[1] is available for formatting the 
 user-message.  See `k8s.wait` for an alias that waits on all pods.

 NB: If the parameter is "all" then this uses --all-namespaces

 USAGE: 
   ./k8s.mk k8s.namespace.wait/<namespace>

 REFS:
   [1]: https://github.com/alecjacobs5401/kubectl-sick-pods
```

 
#### **`k8s.namespace.wait/all`**


```bash 

```

 
#### **`k8s.namespace/<arg>`**


```bash 
Context-manager.  Activates the given namespace.

 NB: This modifies state in the kubeconfig, so that it can effect contexts 
 outside of the current process, therefore this is not thread-safe.

 USAGE:  
	 ./k8s.mk k8s.namespace/<namespace>
```

 
#### **`k8s.shell/<arg>`**


```bash 
This drops into a debugging shell for the named pod using `kubectl exec`,
 plus a streaming version of the same which allows for working with pipes.

 NB: This target assumes that the named pod actually exists.  If you want
 an idempotent create-operation for such a pod.. see `k8s.test_harness`.

 NB: This target attempts to be "universal", so that it may run from the 
 docker host or inside the `k8s:base` container.  This works by detecting 
 aspects of the caller context.  In general, it tries to use k8s-tools.yml 
 when that makes sense and if it's present, falling back to kubectl.

 USAGE: Interactive shell in pod:
   ./k8s.mk k8s.shell/<namespace>/<pod_name>

 USAGE: Stream commands into a pod:
   echo uname -a | ./k8s.mk k8s.shell/<namespace>/<pod_name>/pipe
```

 
#### **`k8s.stat`**


```bash 
Describes status for cluster, cluster auth, and namespaces.
 Not pipe friendly, and not suitable for parsing!  

 This is just for user information, as it's generated from 
 a bunch of tools that are using very different output styles.

 For a shorter, looping version that's suitable as a tmux widget, see 'k8s.stat.widget'
```

 
#### **`k8s.stat.auth`**


```bash 

```

 
#### **`k8s.stat.cluster`**


```bash 

```

 
#### **`k8s.stat.ctx`**


```bash 

```

 
#### **`k8s.stat.env`**


```bash 

```

 
#### **`k8s.stat.node_info`**


```bash 
Status for nodes. 
 Not machine-friendly.  See instead 'k8s.get'.
```

 
#### **`k8s.stat.ns`**


```bash 

```

 
#### **`k8s.test_harness.random`**


```bash 
Starts a test-pod with a random name in the given namespace, optionally blocking until it's ready.

 USAGE: 
	`k8s.test_harness.random`
```

 
#### **`k8s.test_harness/<arg>`**


```bash 
Starts a test-pod in the given namespace, optionally blocking until it's ready.
 When no image is provided, this will use 'ALPINE_K8S_VERSION' as default.

 USAGE: 
	`k8s.test_harness/<namespace>/<pod_name>` or 
	`k8s.test_harness/<namespace>/<pod_name>/<image>`
```

 
#### **`k8s.wait`**


```bash 
Waits until all pods in all namespaces are ready.  (Alias for 'k8s.namespace.wait/all')
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API k3d

The *`k3d.*`* targets describe a small interface for working with `k3d`.  Most targets in this namespace will use k3d directly, and so are usually **dispatched**, and not run from the host.  Most targets are small utilities that can help to keep common tasks idempotent, but there's also a TUI that provides a useful overview of what's going on with K3d:

For more details, read on into the API, or see the [k8s:k3d container spec in k8s-tools.yml](
https://github.com/search?q=repo%3Aelo-enterprises%2Fk8s-tools+path%3Ak8s-tools.yml+content%3Ak3d&type=code)
  



*This documentation is pulled automatically from [source](k8s.mk).*

 
#### **`k3d.cluster.delete/<arg>`**


```bash 
Idempotent version of k3d cluster delete 

 USAGE:
   ./k8s.mk k3d.cluster.delete/<cluster_name>
```

 
#### **`k3d.cluster.list`**


```bash 
Returns cluster-names, newline delimited.

 USAGE:  
   ./k8s.mk k3d.cluster.list
```

 
#### **`k3d.commander`**


```bash 
Starts a 4-pane TUI dashboard, using the commander layout.  
 This opens 'lazydocker', 'ktop', and other widgets that are convenient for working with k3d.

 USAGE:  
   KUBECONFIG=.. ./k8s.mk k3d.commander/<namespace>
```

 
#### **`k3d.commander/<arg>`**


```bash 
Like 'k3d.commander', but additionally sends the given target(s) to the main pane.

 USAGE:
   ./k8s.mk k3d.commander/<target1>,<target2>
```

 
#### **`k3d.help`**


```bash 
Shows targets for just the 'k3d' namespace.
```

 
#### **`k3d.list`**


```bash 
Returns cluster-names, newline delimited.

 USAGE:  
   ./k8s.mk k3d.cluster.list
```

 
#### **`k3d.panic`**


```bash 
Non-graceful stop for everything that is k3d related. 
 
 USAGE:  
   ./k8s.mk k3d.panic
```

 
#### **`k3d.ps`**


```bash 
Container names for everything that is k3d related.

 USAGE:  
   ./k8s.mk k3d.ps
```

 
#### **`k3d.stat`**


```bash 
Show status for k3d.
```

 
#### **`k3d.stat.widget`**


```bash 

```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: kubefwd

The *`kubefwd.*`* targets describe a small interface for working with kubefwd.  It aims to cleanly background / foreground `kubefwd` in an unobtrusive way, with clean setup/teardown and reasonable defaults for usage per-project.  These targets use [the kubefwd container](
https://github.com/search?q=repo%3Aelo-enterprises%2Fk8s-tools+path%3Ak8s-tools.yml+content%3Ak8s%3Akubefwd&type=code), but are generally safe to run from the docker-host.  Forwarding is not just for ports but for DNS as well.  This takes effect everywhere, including the containers in k8s-tools.yml (via /etc/hosts bind-mount), as it does the docker-host.




*This documentation is pulled automatically from [source](k8s.mk).*

 
#### **`kubefwd.help`**


```bash 
Shows targets for just the 'kubefwd' namespace.
```

 
#### **`kubefwd.panic`**


```bash 
Non-graceful stop for everything that is kubefwd related.
 
 Emergency use only; this can clutter up your /etc/hosts
 file as kubefwd may not get a chance to clean things up.
 
 USAGE:  
   ./k8s.mk kubefwd.panic
```

 
#### **`kubefwd.ps`**


```bash 
Container names for everything that is kubefwd related
 
 USAGE:  
   ./k8s.mk kubefwd.ps
```

 
#### **`kubefwd.start/<arg>`**


```bash 
Runs kubefwd for the given namespace, finding and forwarding ports/DNS for the given 
 service, or for all services. This is idempotent, and implicitly stops port-forwarding 
 if it is running, then restarts it. 

 NB: This target should only run from the docker host (not from the kubefwd container),  
 and it assumes k8s-tools.yml is present with that filename. Simple port-mapping and 
 filtering by name is supported; other usage with selectors/labels/reservations/etc 
 should just invoke kubefwd directly.

 USAGE: 
   ./k8s.mk kubefwd/<namespace>
   ./k8s.mk kubefwd/<namespace>/<svc_name>
	 mapping="8080:80" ./k8s.mk kubefwd/<namespace> 
   mapping="8080:80" ./k8s.mk kubefwd/<namespace>/<svc_name>
```

 
#### **`kubefwd.stat`**


```bash 
Display status info for all kubefwd instances that are running
```

 
#### **`kubefwd.stop/<arg>`**


```bash 
Stops the named kubefwd instance.
 This is mostly for internal usage, usually you want 'kubefwd.start' or 'kubefwd.panic'

 USAGE:
	./k8s.mk kubefwd.stop/<namespace>/<svc_name>
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

#### API: helm

Nothing fancy, just a very small interface for idempotent operations with `helm`.  For more details, read on into the API, or see the [`k8s:helm` container spec in k8s-tools.yml](
https://github.com/search?q=repo%3Aelo-enterprises%2Fk8s-tools+path%3Ak8s-tools.yml+content%3Ahelm&type=code).




*This documentation is pulled automatically from [source](k8s.mk).*

 
#### **`helm.chart.install/<arg>`**


```bash 
Idempotent version of a 'helm install'

 USAGE:
   ./k8s.mk helm.chart.install/<name> chart=<chart>
```

 
#### **`helm.repo.add/<arg>`**


```bash 
Idempotent version 'helm repo add'

 USAGE:
   ./k8s.mk helm.repo.add/<repo_name> url=<repo_url>
```



<hr style="width:80%;border-bottom: 5px dashed black;background: #efefef;">

